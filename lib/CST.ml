(* Generated by ocaml-tree-sitter. *)
(*
   r grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type integer = Token.t

type pat_de5d470 = Token.t (* pattern "[^\"\\\\\\n]+|\\\\\\r?\\n" *)

type pat_4ad362e = Token.t (* pattern [^`\\\n]+|\\\r?\n *)

type raw_string_literal = Token.t

type float_ = Token.t

type na = [
    `NA of Token.t (* "NA" *)
  | `NA_char_ of Token.t (* "NA_character_" *)
  | `NA_comp_ of Token.t (* "NA_complex_" *)
  | `NA_int_ of Token.t (* "NA_integer_" *)
  | `NA_real_ of Token.t (* "NA_real_" *)
]

type pat_3e41275 =
  Token.t (* pattern [.\p{XID_Start}][._\p{XID_Continue}]* *)

type semgrep_metavariable = Token.t

type pat_5e7ac5f = Token.t (* pattern [^%\\\n]+|\\\r?\n *)

type escape_sequence = Token.t

type pat_3e57880 = Token.t (* pattern "[^'\\\\\\n]+|\\\\\\r?\\n" *)

type special = (
    Token.t (* "%" *)
  * [ `Pat_5e7ac5f of pat_5e7ac5f | `Esc_seq of escape_sequence (*tok*) ]
      list (* zero or more *)
  * Token.t (* "%" *)
)

type identifier = [
    `Choice_pat_3e41275 of [
        `Pat_3e41275 of pat_3e41275
      | `BQUOT_rep_choice_pat_4ad362e_BQUOT of (
            Token.t (* "`" *)
          * [
                `Pat_4ad362e of pat_4ad362e
              | `Esc_seq of escape_sequence (*tok*)
            ]
              list (* zero or more *)
          * Token.t (* "`" *)
        )
    ]
  | `Semg_meta of semgrep_metavariable (*tok*)
]

type string_ = [
    `Raw_str_lit of raw_string_literal (*tok*)
  | `DQUOT_rep_choice_pat_de5d470_DQUOT of (
        Token.t (* "\"" *)
      * [ `Pat_de5d470 of pat_de5d470 | `Esc_seq of escape_sequence (*tok*) ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `SQUOT_rep_choice_pat_3e57880_SQUOT of (
        Token.t (* "'" *)
      * [ `Pat_3e57880 of pat_3e57880 | `Esc_seq of escape_sequence (*tok*) ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]

type argument = [ `Exp of expression | `Defa_arg of default_argument ]

and arguments =
  [ `Arg of argument | `COMMA of Token.t (* "," *) ] list (* one or more *)

and assignment = [
    `Equals_assign of (expression * Token.t (* "=" *) * expression)
  | `Left_assign of (expression * Token.t (* "<-" *) * expression)
  | `Left_assign2 of (expression * Token.t (* ":=" *) * expression)
  | `Right_assign of (expression * Token.t (* "->" *) * expression)
  | `Super_assign of (expression * Token.t (* "<<-" *) * expression)
  | `Super_right_assign of (expression * Token.t (* "->>" *) * expression)
]

and binary = [
    `Exp_choice_PLUS_exp of (
        expression
      * [ `PLUS of Token.t (* "+" *) | `DASH of Token.t (* "-" *) ]
      * expression
    )
  | `Exp_choice_STAR_exp of (
        expression
      * [ `STAR of Token.t (* "*" *) | `SLASH of Token.t (* "/" *) ]
      * expression
    )
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_choice_LT_exp of (
        expression
      * [
            `LT of Token.t (* "<" *)
          | `GT of Token.t (* ">" *)
          | `LTEQ of Token.t (* "<=" *)
          | `GTEQ of Token.t (* ">=" *)
          | `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
        ]
      * expression
    )
  | `Exp_choice_BARBAR_exp of (
        expression
      * [ `BARBAR of Token.t (* "||" *) | `BAR of Token.t (* "|" *) ]
      * expression
    )
  | `Exp_choice_AMPAMP_exp of (
        expression
      * [ `AMPAMP of Token.t (* "&&" *) | `AMP of Token.t (* "&" *) ]
      * expression
    )
  | `Exp_spec_exp of (expression * special * expression)
  | `Exp_COLON_exp of (expression * Token.t (* ":" *) * expression)
  | `Exp_TILDE_exp of (expression * Token.t (* "~" *) * expression)
]

and default_argument = (
    [ `Id of identifier | `Str of string_ | `Dots of Token.t (* "..." *) ]
  * Token.t (* "=" *)
  * expression option
)

and expression = [
    `Id of identifier
  | `Int of integer (*tok*)
  | `Float of float_ (*tok*)
  | `Comp of (float_ (*tok*) * Token.t (* "i" *))
  | `Str of string_
  | `Call of (
        expression
      * Token.t (* "(" *)
      * arguments option
      * Token.t (* ")" *)
    )
  | `Func_defi of function_definition
  | `Lambda_func of lambda_function
  | `Assign of assignment
  | `Brace_list of (Token.t (* "{" *) * program * Token.t (* "}" *))
  | `Paren_list of (
        Token.t (* "(" *)
      * expression list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `Bin of binary
  | `Un of unary
  | `Pipe of (expression * Token.t (* "|>" *) * pipe_rhs)
  | `Subset of (
        expression
      * Token.t (* "[" *)
      * arguments option
      * Token.t (* "]" *)
    )
  | `Subset2 of (
        expression
      * Token.t (* "[[" *)
      * arguments option
      * Token.t (* "]]" *)
    )
  | `Dollar of (
        expression
      * Token.t (* "$" *)
      * [ `Id of identifier | `Str of string_ ]
    )
  | `Slot of (expression * Token.t (* "@" *) * identifier)
  | `Name_get of (identifier * Token.t (* "::" *) * identifier)
  | `Name_get_inte of (identifier * Token.t (* ":::" *) * identifier)
  | `If of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * expression
      * (Token.t (* "else" *) * expression) option
    )
  | `For of (
        Token.t (* "for" *) * Token.t (* "(" *) * identifier
      * Token.t (* "in" *) * expression * Token.t (* ")" *) * expression
    )
  | `While of (
        Token.t (* "while" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * expression
    )
  | `Repeat of (Token.t (* "repeat" *) * expression)
  | `Switch of (
        Token.t (* "switch" *) * Token.t (* "(" *) * expression
      * Token.t (* "," *) * arguments * Token.t (* ")" *)
    )
  | `Brk of Token.t (* "break" *)
  | `Next of Token.t (* "next" *)
  | `True of Token.t (* "TRUE" *)
  | `False of Token.t (* "FALSE" *)
  | `Null of Token.t (* "NULL" *)
  | `Inf of Token.t (* "Inf" *)
  | `Nan of Token.t (* "NaN" *)
  | `Na of na
  | `Dots of Token.t (* "..." *)
]

and formal_parameter = [
    `Id of identifier
  | `Defa_param of (identifier * Token.t (* "=" *) * expression)
  | `Dots of Token.t (* "..." *)
]

and formal_parameters = (
    Token.t (* "(" *)
  * (
        formal_parameter
      * (Token.t (* "," *) * formal_parameter) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and function_definition = (
    Token.t (* "function" *) * formal_parameters * expression
)

and lambda_function = (Token.t (* "\\" *) * formal_parameters * expression)

and pipe_rhs = (
    expression
  * Token.t (* "(" *)
  * pipe_rhs_arguments option
  * Token.t (* ")" *)
)

and pipe_rhs_argument = [
    `Exp of expression
  | `Defa_arg of default_argument
  | `Pipe_plac_arg of (identifier * Token.t (* "=" *) * Token.t (* "_" *))
]

and pipe_rhs_arguments =
  [ `Pipe_rhs_arg of pipe_rhs_argument | `COMMA of Token.t (* "," *) ]
    list (* one or more *)

and program =
  (
      expression
    * [ `LF of Token.t (* "\n" *) | `SEMI of Token.t (* ";" *) ] option
  )
    list (* zero or more *)

and unary = [
    `Choice_DASH_exp of (
        [ `DASH of Token.t (* "-" *) | `PLUS of Token.t (* "+" *) ]
      * expression
    )
  | `BANG_exp of (Token.t (* "!" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
]

type null (* inlined *) = Token.t (* "NULL" *)

type placeholder (* inlined *) = Token.t (* "_" *)

type true_ (* inlined *) = Token.t (* "TRUE" *)

type false_ (* inlined *) = Token.t (* "FALSE" *)

type comment (* inlined *) = Token.t

type nan (* inlined *) = Token.t (* "NaN" *)

type inf (* inlined *) = Token.t (* "Inf" *)

type next (* inlined *) = Token.t (* "next" *)

type dots (* inlined *) = Token.t (* "..." *)

type break (* inlined *) = Token.t (* "break" *)

type complex (* inlined *) = (float_ (*tok*) * Token.t (* "i" *))

type namespace_get (* inlined *) = (
    identifier * Token.t (* "::" *) * identifier
)

type namespace_get_internal (* inlined *) = (
    identifier * Token.t (* ":::" *) * identifier
)

type pipe_placeholder_argument (* inlined *) = (
    identifier * Token.t (* "=" *) * Token.t (* "_" *)
)

type brace_list (* inlined *) = (
    Token.t (* "{" *) * program * Token.t (* "}" *)
)

type call (* inlined *) = (
    expression
  * Token.t (* "(" *)
  * arguments option
  * Token.t (* ")" *)
)

type default_parameter (* inlined *) = (
    identifier * Token.t (* "=" *) * expression
)

type dollar (* inlined *) = (
    expression
  * Token.t (* "$" *)
  * [ `Id of identifier | `Str of string_ ]
)

type equals_assignment (* inlined *) = (
    expression * Token.t (* "=" *) * expression
)

type for_ (* inlined *) = (
    Token.t (* "for" *) * Token.t (* "(" *) * identifier * Token.t (* "in" *)
  * expression * Token.t (* ")" *) * expression
)

type if_ (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * expression
  * (Token.t (* "else" *) * expression) option
)

type left_assignment (* inlined *) = (
    expression * Token.t (* "<-" *) * expression
)

type left_assignment2 (* inlined *) = (
    expression * Token.t (* ":=" *) * expression
)

type paren_list (* inlined *) = (
    Token.t (* "(" *)
  * expression list (* zero or more *)
  * Token.t (* ")" *)
)

type pipe (* inlined *) = (expression * Token.t (* "|>" *) * pipe_rhs)

type repeat (* inlined *) = (Token.t (* "repeat" *) * expression)

type right_assignment (* inlined *) = (
    expression * Token.t (* "->" *) * expression
)

type slot (* inlined *) = (expression * Token.t (* "@" *) * identifier)

type subset (* inlined *) = (
    expression
  * Token.t (* "[" *)
  * arguments option
  * Token.t (* "]" *)
)

type subset2 (* inlined *) = (
    expression
  * Token.t (* "[[" *)
  * arguments option
  * Token.t (* "]]" *)
)

type super_assignment (* inlined *) = (
    expression * Token.t (* "<<-" *) * expression
)

type super_right_assignment (* inlined *) = (
    expression * Token.t (* "->>" *) * expression
)

type switch (* inlined *) = (
    Token.t (* "switch" *) * Token.t (* "(" *) * expression
  * Token.t (* "," *) * arguments * Token.t (* ")" *)
)

type while_ (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * expression
)

type block (* inlined *) = (
    Token.t (* "{" *)
  * expression list (* zero or more *)
  * Token.t (* "}" *)
)

type definition (* inlined *) = [
    `Func_defi of function_definition
  | `Lambda_func of lambda_function
]

type extra = [ `Comment of Loc.t * comment ]

type extras = extra list
