(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_r"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "null", None;
  "placeholder", None;
  "true", None;
  "integer", None;
  "false", None;
  "pat_de5d470", None;
  "nan", None;
  "pat_4ad362e", None;
  "inf", None;
  "float", None;
  "na",
  Some (
    Alt [|
      Token (Literal "NA");
      Token (Literal "NA_character_");
      Token (Literal "NA_complex_");
      Token (Literal "NA_integer_");
      Token (Literal "NA_real_");
    |];
  );
  "pat_3e41275", None;
  "next", None;
  "dots", None;
  "raw_string_literal", None;
  "pat_5e7ac5f", None;
  "escape_sequence", None;
  "break", None;
  "pat_3e57880", None;
  "complex",
  Some (
    Seq [
      Token (Name "float");
      Token (Literal "i");
    ];
  );
  "special",
  Some (
    Seq [
      Token (Literal "%");
      Repeat (
        Alt [|
          Token (Name "pat_5e7ac5f");
          Token (Name "escape_sequence");
        |];
      );
      Token (Literal "%");
    ];
  );
  "identifier",
  Some (
    Alt [|
      Token (Name "pat_3e41275");
      Seq [
        Token (Literal "`");
        Repeat (
          Alt [|
            Token (Name "pat_4ad362e");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "`");
      ];
    |];
  );
  "string",
  Some (
    Alt [|
      Token (Name "raw_string_literal");
      Seq [
        Token (Literal "\"");
        Repeat (
          Alt [|
            Token (Name "pat_de5d470");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "\"");
      ];
      Seq [
        Token (Literal "'");
        Repeat (
          Alt [|
            Token (Name "pat_3e57880");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "'");
      ];
    |];
  );
  "namespace_get",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "::");
      Token (Name "identifier");
    ];
  );
  "namespace_get_internal",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ":::");
      Token (Name "identifier");
    ];
  );
  "pipe_placeholder_argument",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "placeholder");
    ];
  );
  "argument",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "default_argument");
    |];
  );
  "arguments",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "argument");
        Token (Literal ",");
      |];
    );
  );
  "assignment",
  Some (
    Alt [|
      Token (Name "equals_assignment");
      Token (Name "left_assignment");
      Token (Name "left_assignment2");
      Token (Name "right_assignment");
      Token (Name "super_assignment");
      Token (Name "super_right_assignment");
    |];
  );
  "binary",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "+");
          Token (Literal "-");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "*");
          Token (Literal "/");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "<");
          Token (Literal ">");
          Token (Literal "<=");
          Token (Literal ">=");
          Token (Literal "==");
          Token (Literal "!=");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "||");
          Token (Literal "|");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "&&");
          Token (Literal "&");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Name "special");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ":");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "~");
        Token (Name "expression");
      ];
    |];
  );
  "brace_list",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Token (Name "expression");
          Opt (
            Alt [|
              Token (Literal "\n");
              Token (Literal ";");
            |];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "call",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "(");
      Opt (
        Token (Name "arguments");
      );
      Token (Literal ")");
    ];
  );
  "default_argument",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "string");
        Token (Name "dots");
      |];
      Token (Literal "=");
      Opt (
        Token (Name "expression");
      );
    ];
  );
  "default_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "dollar",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "$");
      Alt [|
        Token (Name "identifier");
        Token (Name "string");
      |];
    ];
  );
  "equals_assignment",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "integer");
      Token (Name "float");
      Token (Name "complex");
      Token (Name "string");
      Token (Name "call");
      Token (Name "function_definition");
      Token (Name "lambda_function");
      Token (Name "assignment");
      Token (Name "brace_list");
      Token (Name "paren_list");
      Token (Name "binary");
      Token (Name "unary");
      Token (Name "pipe");
      Token (Name "subset");
      Token (Name "subset2");
      Token (Name "dollar");
      Token (Name "slot");
      Token (Name "namespace_get");
      Token (Name "namespace_get_internal");
      Token (Name "if");
      Token (Name "for");
      Token (Name "while");
      Token (Name "repeat");
      Token (Name "switch");
      Token (Name "break");
      Token (Name "next");
      Token (Name "true");
      Token (Name "false");
      Token (Name "null");
      Token (Name "inf");
      Token (Name "nan");
      Token (Name "na");
      Token (Name "dots");
    |];
  );
  "for",
  Some (
    Seq [
      Token (Literal "for");
      Token (Literal "(");
      Token (Name "identifier");
      Token (Literal "in");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "expression");
    ];
  );
  "formal_parameter",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "default_parameter");
      Token (Name "dots");
    |];
  );
  "formal_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "formal_parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "formal_parameter");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "function_definition",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "formal_parameters");
      Token (Name "expression");
    ];
  );
  "if",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "expression");
        ];
      );
    ];
  );
  "lambda_function",
  Some (
    Seq [
      Token (Literal "\\");
      Token (Name "formal_parameters");
      Token (Name "expression");
    ];
  );
  "left_assignment",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "<-");
      Token (Name "expression");
    ];
  );
  "left_assignment2",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal ":=");
      Token (Name "expression");
    ];
  );
  "paren_list",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Token (Name "expression");
      );
      Token (Literal ")");
    ];
  );
  "pipe",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "|>");
      Token (Name "pipe_rhs");
    ];
  );
  "pipe_rhs",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "(");
      Opt (
        Token (Name "pipe_rhs_arguments");
      );
      Token (Literal ")");
    ];
  );
  "pipe_rhs_argument",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "default_argument");
      Token (Name "pipe_placeholder_argument");
    |];
  );
  "pipe_rhs_arguments",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "pipe_rhs_argument");
        Token (Literal ",");
      |];
    );
  );
  "repeat",
  Some (
    Seq [
      Token (Literal "repeat");
      Token (Name "expression");
    ];
  );
  "right_assignment",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "->");
      Token (Name "expression");
    ];
  );
  "slot",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "@");
      Token (Name "identifier");
    ];
  );
  "subset",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "[");
      Opt (
        Token (Name "arguments");
      );
      Token (Literal "]");
    ];
  );
  "subset2",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "[[");
      Opt (
        Token (Name "arguments");
      );
      Token (Literal "]]");
    ];
  );
  "super_assignment",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "<<-");
      Token (Name "expression");
    ];
  );
  "super_right_assignment",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "->>");
      Token (Name "expression");
    ];
  );
  "switch",
  Some (
    Seq [
      Token (Literal "switch");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ",");
      Token (Name "arguments");
      Token (Literal ")");
    ];
  );
  "unary",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Literal "-");
          Token (Literal "+");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "!");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expression");
      ];
    |];
  );
  "while",
  Some (
    Seq [
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "expression");
    ];
  );
  "program",
  Some (
    Repeat (
      Seq [
        Token (Name "expression");
        Opt (
          Alt [|
            Token (Literal "\n");
            Token (Literal ";");
          |];
        );
      ];
    );
  );
]

let trans_null ((kind, body) : mt) : CST.null =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_placeholder ((kind, body) : mt) : CST.placeholder =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_integer ((kind, body) : mt) : CST.integer =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_de5d470 ((kind, body) : mt) : CST.pat_de5d470 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_nan ((kind, body) : mt) : CST.nan =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_4ad362e ((kind, body) : mt) : CST.pat_4ad362e =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_inf ((kind, body) : mt) : CST.inf =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_float_ ((kind, body) : mt) : CST.float_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_na ((kind, body) : mt) : CST.na =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `NA (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `NA_char_ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `NA_comp_ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `NA_int_ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `NA_real_ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_3e41275 ((kind, body) : mt) : CST.pat_3e41275 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_next ((kind, body) : mt) : CST.next =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_dots ((kind, body) : mt) : CST.dots =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_raw_string_literal ((kind, body) : mt) : CST.raw_string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_5e7ac5f ((kind, body) : mt) : CST.pat_5e7ac5f =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_break ((kind, body) : mt) : CST.break =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_3e57880 ((kind, body) : mt) : CST.pat_3e57880 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_complex ((kind, body) : mt) : CST.complex =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_float_ (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_special ((kind, body) : mt) : CST.special =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Pat_5e7ac5f (
                      trans_pat_5e7ac5f (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_3e41275 (
            trans_pat_3e41275 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `BQUOT_rep_choice_pat_4ad362e_BQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Pat_4ad362e (
                            trans_pat_4ad362e (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Raw_str_lit (
            trans_raw_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DQUOT_rep_choice_pat_de5d470_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Pat_de5d470 (
                            trans_pat_de5d470 (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `SQUOT_rep_choice_pat_3e57880_SQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Pat_3e57880 (
                            trans_pat_3e57880 (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_namespace_get ((kind, body) : mt) : CST.namespace_get =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_namespace_get_internal ((kind, body) : mt) : CST.namespace_get_internal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pipe_placeholder_argument ((kind, body) : mt) : CST.pipe_placeholder_argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_placeholder (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_argument ((kind, body) : mt) : CST.argument =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Defa_arg (
            trans_default_argument (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_arguments ((kind, body) : mt) : CST.arguments =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Arg (
                trans_argument (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `COMMA (
                Run.trans_token (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_assignment ((kind, body) : mt) : CST.assignment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Equals_assign (
            trans_equals_assignment (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Left_assign (
            trans_left_assignment (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Left_assign2 (
            trans_left_assignment2 (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Right_assign (
            trans_right_assignment (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Super_assign (
            trans_super_assignment (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Super_right_assign (
            trans_super_right_assignment (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary ((kind, body) : mt) : CST.binary =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_choice_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_choice_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `SLASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_HAT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_choice_LT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `LT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `GT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `LTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `GTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (4, v) ->
                      `EQEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (5, v) ->
                      `BANGEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_choice_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `BARBAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `BAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_choice_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `AMPAMP (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `AMP (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_spec_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_special (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_COLON_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_TILDE_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_brace_list ((kind, body) : mt) : CST.brace_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Alt (0, v) ->
                              `LF (
                                Run.trans_token (Run.matcher_token v)
                              )
                          | Alt (1, v) ->
                              `SEMI (
                                Run.trans_token (Run.matcher_token v)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call ((kind, body) : mt) : CST.call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_arguments (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_argument ((kind, body) : mt) : CST.default_argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Str (
                  trans_string_ (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Dots (
                  trans_dots (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_parameter ((kind, body) : mt) : CST.default_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dollar ((kind, body) : mt) : CST.dollar =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Str (
                  trans_string_ (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_equals_assignment ((kind, body) : mt) : CST.equals_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Int (
            trans_integer (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Float (
            trans_float_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Comp (
            trans_complex (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Str (
            trans_string_ (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Call (
            trans_call (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Func_defi (
            trans_function_definition (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Lambda_func (
            trans_lambda_function (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Assign (
            trans_assignment (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Brace_list (
            trans_brace_list (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Paren_list (
            trans_paren_list (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Bin (
            trans_binary (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Un (
            trans_unary (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Pipe (
            trans_pipe (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Subset (
            trans_subset (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Subset2 (
            trans_subset2 (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Dollar (
            trans_dollar (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Slot (
            trans_slot (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Name_get (
            trans_namespace_get (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Name_get_inte (
            trans_namespace_get_internal (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `If (
            trans_if_ (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `For (
            trans_for_ (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `While (
            trans_while_ (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Repeat (
            trans_repeat (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Switch (
            trans_switch (Run.matcher_token v)
          )
      | Alt (25, v) ->
          `Brk (
            trans_break (Run.matcher_token v)
          )
      | Alt (26, v) ->
          `Next (
            trans_next (Run.matcher_token v)
          )
      | Alt (27, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (28, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | Alt (29, v) ->
          `Null (
            trans_null (Run.matcher_token v)
          )
      | Alt (30, v) ->
          `Inf (
            trans_inf (Run.matcher_token v)
          )
      | Alt (31, v) ->
          `Nan (
            trans_nan (Run.matcher_token v)
          )
      | Alt (32, v) ->
          `Na (
            trans_na (Run.matcher_token v)
          )
      | Alt (33, v) ->
          `Dots (
            trans_dots (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_ ((kind, body) : mt) : CST.for_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            trans_expression (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameter ((kind, body) : mt) : CST.formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Defa_param (
            trans_default_parameter (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Dots (
            trans_dots (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameters ((kind, body) : mt) : CST.formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_formal_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_formal_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_definition ((kind, body) : mt) : CST.function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_formal_parameters (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_ ((kind, body) : mt) : CST.if_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_function ((kind, body) : mt) : CST.lambda_function =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_formal_parameters (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_left_assignment ((kind, body) : mt) : CST.left_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_left_assignment2 ((kind, body) : mt) : CST.left_assignment2 =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_paren_list ((kind, body) : mt) : CST.paren_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pipe ((kind, body) : mt) : CST.pipe =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_pipe_rhs (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pipe_rhs ((kind, body) : mt) : CST.pipe_rhs =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_pipe_rhs_arguments (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pipe_rhs_argument ((kind, body) : mt) : CST.pipe_rhs_argument =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Defa_arg (
            trans_default_argument (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pipe_plac_arg (
            trans_pipe_placeholder_argument (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pipe_rhs_arguments ((kind, body) : mt) : CST.pipe_rhs_arguments =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Pipe_rhs_arg (
                trans_pipe_rhs_argument (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `COMMA (
                Run.trans_token (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_repeat ((kind, body) : mt) : CST.repeat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_right_assignment ((kind, body) : mt) : CST.right_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_slot ((kind, body) : mt) : CST.slot =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_subset ((kind, body) : mt) : CST.subset =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_arguments (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_subset2 ((kind, body) : mt) : CST.subset2 =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_arguments (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_super_assignment ((kind, body) : mt) : CST.super_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_super_right_assignment ((kind, body) : mt) : CST.super_right_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch ((kind, body) : mt) : CST.switch =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_arguments (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary ((kind, body) : mt) : CST.unary =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_DASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `BANG_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `TILDE_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_ ((kind, body) : mt) : CST.while_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_program ((kind, body) : mt) : CST.program =
  match body with
  | Children v ->
      Run.repeat
        (fun v ->
          (match v with
          | Seq [v0; v1] ->
              (
                trans_expression (Run.matcher_token v0),
                Run.opt
                  (fun v ->
                    (match v with
                    | Alt (0, v) ->
                        `LF (
                          Run.trans_token (Run.matcher_token v)
                        )
                    | Alt (1, v) ->
                        `SEMI (
                          Run.trans_token (Run.matcher_token v)
                        )
                    | _ -> assert false
                    )
                  )
                  v1
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false


let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_program matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

